<!DOCTYPE html>
<meta charset="utf-8">

<link href="https://cdnjs.cloudflare.com/ajax/libs/chosen/1.8.2/chosen.min.css" rel="stylesheet" />

<style>
body {
  overflow:hidden;
   margin:0;
}
text {
  font-family: sans-serif;
  pointer-events: none;
}
.legend_container {
    position: fixed;
    width: 15vw;
    height: 94vh;
    left: 2vw;
    top: 3vh;
    border: 2px solid black;
    background-color: white;
}
.input {

}
</style>
<body>

    <input type="text" class="input" id="magic" list="nodes" />
    <datalist id="nodes">
      {% for node in nodes %}<option value="{{node}}">{{node}}</option>{% endfor %}
    </datalist>

    <input type="checkbox" id="solutionEdges" name="solutionEdges" value="solutionEdges">
    <label for="solutionEdges">Only show PCSF solution edges</label>

    <button id="saveButton">
        <big>â‡©</big> Download PNG
    </button>

    <!-- <div class="legend_container"></div> -->

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.24.0/d3-legend.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.slim.min.js"></script>
<script src="https://cdn.rawgit.com/eligrey/canvas-toBlob.js/f1a01896135ab378aa5c0118eadd81da55e698d8/canvas-toBlob.js"></script>
<script src="https://cdn.rawgit.com/eligrey/FileSaver.js/e9d941381475b5df8b7d7691013401e171014e89/FileSaver.min.js"></script>
<script>
var w = window.innerWidth;
var h = window.innerHeight;

var graph = {{ graph_json|safe }}

var focus_node = null,
    highlight_node = null;

/////////////////////////////////////////////////////////////////////////////
                      ///////    Scales    ///////
/////////////////////////////////////////////////////////////////////////////

var min_score = 0;
var max_score = 4;

var min_confidence = 0;
var max_confidence = 1;

// var color = d3.scaleLinear()
//                     .domain([min_score, (min_score + max_score) / 2, max_score])
                    // .range(["blue", "white", "red"]);
var color = d3.scaleLinear()
              .domain([min_score, max_score])
              .range(["white", "red"]);

var width = d3.scaleLinear()
              .domain([min_confidence, max_confidence])
              .range([0.2, 2]);

var display_type = d3.scaleOrdinal()
                     .domain(['protein', 'TF', 'metabolite'])
                     .range([d3.symbolCircle, d3.symbolTriangl, d3.symbolDiamond] );

var size = d3.scalePow()
             .exponent(1)
             .domain([1, 100])
             .range([8, 24]);

/////////////////////////////////////////////////////////////////////////////
                      ///////    Variables    ///////
/////////////////////////////////////////////////////////////////////////////

var text_center = false;
var outline = false;
var highlight_color = "blue";
var highlight_trans = 0.1;
var default_node_color = "#ccc";
var default_link_color = "#888";
var nominal_base_node_size = 8;
var nominal_text_size = 10;
var max_text_size = 24;
var default_stroke_width = 1;
var max_stroke = 16;
var max_base_node_size = 36;
var min_zoom = 0.2;
var max_zoom = 7;
var svg = d3.select("body").append("svg");
var g = svg.append("g");
svg.style("cursor", "move");

/////////////////////////////////////////////////////////////////////////////
                      ///////    Helpers    ///////
/////////////////////////////////////////////////////////////////////////////

var linked = {};
graph.links.forEach(function(d) { linked[d.source + "," + d.target] = true; });

function isConnected(a, b) {
    return linked[a.id + "," + b.id] || linked[b.id + "," + a.id] || a.id == b.id;
}

function hasConnections(a) {
    for (var property in linked) {
        s = property.split(",");
        if ((s[0] == a.id || s[1] == a.id) && linked[property]) return true;
    }
    return false;
}

function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}

/////////////////////////////////////////////////////////////////////////////
                      ///////    Force    ///////
/////////////////////////////////////////////////////////////////////////////


// var force = d3.forceSimulation()
//               .force("link", d3.forceLink().id(function(d) { return d.id; }))
//               .force("charge", d3.forceManyBody().strength(-300))
//               .force("center", d3.forceCenter(w / 2, h / 2))
//               .alphaTarget(1)
//               .on("tick", function() {

//                     node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
//                     text.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

//                     link.attr("x1", function(d) { return d.source.x; })
//                         .attr("y1", function(d) { return d.source.y; })
//                         .attr("x2", function(d) { return d.target.x; })
//                         .attr("y2", function(d) { return d.target.y; });

//                     node.attr("cx", function(d) { return d.x; })
//                         .attr("cy", function(d) { return d.y; });
//                 });

// var link = g.selectAll(".link")
//             .data(graph.links)
//             .enter().append("line")
//             .attr("class", "link")
//             .style("stroke-width", function(d) {
//                 if (isNumber(d.cost) && d.cost >= 0) return width(1-d.cost);
//                 else return default_stroke_width;
//             })
//             .style("stroke", function(d) {
//                 if (isNumber(d.score) && d.score >= 0) return color(d.score);
//                 else return default_link_color;
//             })

// var node = g.selectAll(".node")
//             .data(graph.nodes)
//             .enter().append("g")
//             .attr("class", "node")
//             .attr("id", function(d) { return d.id; })

// function restart() {

//     // Apply the general update pattern to the nodes.
//     node = g.selectAll(".node").data(graph.nodes, function(d) { return d.id;});
//     node.exit().remove();
//     node = node.enter().append("g")
//                        .attr("class", "node")
//                        .attr("id", function(d) { return d.id; })

//     // Apply the general update pattern to the links.
//     link = link.data(graph.links, function(d) { return d.source.id + "-" + d.target.id; });
//     link.exit().remove();
//     link = link.enter().append("line").merge(link)
//                      .attr("class", "link")
//                      .style("stroke-width", function(d) {
//                          if (isNumber(d.cost) && d.cost >= 0) return width(1-d.cost);
//                          else return default_stroke_width;
//                      })
//                      .style("stroke", function(d) {
//                          if (isNumber(d.score) && d.score >= 0) return color(d.score);
//                          else return default_link_color;
//                      })

//     var tocolor = "fill";
//     var towhite = "stroke";
//     if (outline) {
//         tocolor = "stroke"
//         towhite = "fill"
//     }

//     var circle = node.append("path")
//         .attr("d", d3.symbol()
//             .size(function(d) { return Math.PI * Math.pow(size(d.size) || nominal_base_node_size, 2); })
//             .type(function(d) { return display_type(d.type);
//         }))
//         .style(tocolor, function(d) {
//             if (isNumber(d.prize) && d.prize >= 0) return color(d.prize);
//             else return default_node_color;
//         })
//         .style("stroke-width", default_stroke_width)
//         .style(towhite, "white");

//     var text = g.selectAll(".text")
//                 .data(graph.nodes)
//                 .enter().append("text")
//                 .attr("dy", ".35em")
//                 .style("font-size", nominal_text_size + "px")

//     if (text_center) {
//         text.text(function(d) { return d.id; })
//             .style("text-anchor", "middle");
//     } else {
//         text.attr("dx", function(d) { return (size(d.size) || nominal_base_node_size); })
//             .text(function(d) { return '\u2002' + d.id; });
//     }


//     // Update and restart the simulation.
//     force.nodes(graph.nodes);
//     force.force("link").links(graph.links);
//     force.alpha(1).restart();
// }


// restart();


var force = d3.forceSimulation()
              .force("link", d3.forceLink().id(function(d) { return d.id; }))
              .force("charge", d3.forceManyBody().strength(-300))
              .force("center", d3.forceCenter(w / 2, h / 2));

var link = g.selectAll(".link")
            .data(graph.links)
            .enter().append("line")
            .attr("class", "link")
            .style("stroke-width", function(d) {
                if (isNumber(d.cost) && d.cost >= 0) return width(1-d.cost);
                else return default_stroke_width;
            })
            .style("stroke", function(d) {
                if (isNumber(d.score) && d.score >= 0) return color(d.score);
                else return default_link_color;
            })

var node = g.selectAll(".node")
            .data(graph.nodes)
            .enter().append("g")
            .attr("class", "node")
            .attr("id", function(d) { return d.id; })

force.nodes(graph.nodes).on("tick", function() {

    node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
    text.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node.attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });

});

force.force("link").links(graph.links);


/////////////////////////////////////////////////////////////////////////////
                      ///////    Drag    ///////
/////////////////////////////////////////////////////////////////////////////

var drag_handler = d3.drag()
    .on("start", drag_start)
    .on("drag", drag_drag)
    .on("end", drag_end);

drag_handler(node);

function drag_start(d) {
    if (!d3.event.active) { force.alphaTarget(0.3).restart(); }
    set_focus(d);
    d.fx = d.x;
    d.fy = d.y;
}

function drag_drag(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function drag_end(d) {
  if (!d3.event.active) { force.alphaTarget(0); }
  remove_focus(d)
  d.fx = null;
  d.fy = null;
}

/////////////////////////////////////////////////////////////////////////////
                      ///////    Zoom    ///////
/////////////////////////////////////////////////////////////////////////////

function zoom_actions() { g.attr("transform", d3.event.transform) }
var zoom_handler = d3.zoom().scaleExtent([min_zoom, max_zoom]).on("zoom", zoom_actions);
zoom_handler(svg);

node.on("dblclick.zoom", function(d) {
    d3.event.stopPropagation();
    var dcx = (window.innerWidth / 2 - d.x * zoom.scale());
    var dcy = (window.innerHeight / 2 - d.y * zoom.scale());
    zoom.translate([dcx, dcy]);
    g.attr("transform", "translate(" + dcx + "," + dcy + ")scale(" + zoom.scale() + ")");
});

/////////////////////////////////////////////////////////////////////////////
                      ///////    Draw Graph    ///////
/////////////////////////////////////////////////////////////////////////////

var tocolor = "fill";
var towhite = "stroke";
if (outline) {
    tocolor = "stroke"
    towhite = "fill"
}

var circle = node.append("path")
    .attr("d", d3.symbol()
        .size(function(d) { return Math.PI * Math.pow(size(d.size) || nominal_base_node_size, 2); })
        .type(function(d) { return display_type(d.type);
    }))
    .style(tocolor, function(d) {
        if (isNumber(d.prize) && d.prize >= 0) return color(d.prize);
        else return default_node_color;
    })
    .style("stroke-width", default_stroke_width)
    .style(towhite, "white");

var text = g.selectAll(".text")
            .data(graph.nodes)
            .enter().append("text")
            .attr("dy", ".35em")
            .style("font-size", nominal_text_size + "px")

if (text_center) {
    text.text(function(d) { return d.id; })
        .style("text-anchor", "middle");
} else {
    text.attr("dx", function(d) { return (size(d.size) || nominal_base_node_size); })
        .text(function(d) { return '\u2002' + d.id; });
}

/////////////////////////////////////////////////////////////////////////////
                      ///////    Highlight    ///////
/////////////////////////////////////////////////////////////////////////////

node.on("mouseover", function(d) { set_highlight(d); }).on("mouseout", function(d) { remove_highlight(); });

function set_highlight(d) {
    svg.style("cursor", "pointer");
    if (focus_node !== null) d = focus_node;
    highlight_node = d;

    if (highlight_color != "white") {
        circle.style(towhite, function(o) {
            return isConnected(d, o) ? highlight_color : "white";
        });
        text.style("font-weight", function(o) {
            return isConnected(d, o) ? "bold" : "normal";
        });
        link.style("stroke", function(o) {
            return o.source.index == d.index || o.target.index == d.index ? highlight_color : ((isNumber(o.score) && o.score >= 0) ? color(o.score) : default_link_color);
        });
    }
}

function remove_highlight() {
    highlight_node = null;
    if (focus_node === null) {
        svg.style("cursor", "move");
        if (highlight_color != "white") {
            circle.style(towhite, "white");
            text.style("font-weight", "normal");
            link.style("stroke", function(o) {
                return (isNumber(o.score) && o.score >= 0) ? color(o.score) : default_link_color
            });
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
                      ///////    Focus    ///////
/////////////////////////////////////////////////////////////////////////////

function set_focus(d) {
    if (highlight_trans < 1) {
        circle.style("opacity", function(o) { return isConnected(d, o) ? 1 : highlight_trans; });
        text.style("opacity", function(o) { return isConnected(d, o) ? 1 : highlight_trans; });
        link.style("opacity", function(o) { return o.source.index == d.index || o.target.index == d.index ? 1 : highlight_trans; });
    }
}

function remove_focus() {
    focus_node = null;
    circle.style("opacity", 1);
    text.style("opacity", 1);
    link.style("opacity", 1);
    if (highlight_node === null) { remove_highlight(); }
}

/////////////////////////////////////////////////////////////////////////////
                      ///////    Resize    ///////
/////////////////////////////////////////////////////////////////////////////

function resize() {
    w = window.innerWidth;
    h = window.innerHeight;
    svg.attr("width", window.innerWidth).attr("height", window.innerHeight);
}

d3.select(window).on("resize", resize)

resize();

/////////////////////////////////////////////////////////////////////////////
                      ///////    Legends    ///////
/////////////////////////////////////////////////////////////////////////////

// COLOR LEGEND
svg.append("g")
   .attr("class", "legendLinear")
   .attr("transform", "translate(20,20)");

var legendLinear = d3.legendColor()
                     .shapeWidth(30)
                     .orient('vertical')
                     .scale(color)
                     .title("Node Prizes");

svg.select(".legendLinear")
   .call(legendLinear);

// // SIZE LEGEND
// svg.append("g")
//    .attr("class", "legendSizeLine")
//    .attr("transform", "translate(20, 500)");

// var legendSizeLine = d3.legendSize()
//                        .scale(width)
//                        .shape("line")
//                        .orient("vertical")
//                        // .labels(["tiny", "small", "medium", "large", "grand"])
//                        .shapeWidth(40)
//                        .labelAlign("start")
//                        .shapePadding(10);

// svg.select(".legendSizeLine")
//    .call(legendSizeLine);

// SYMBOL LEGEND
// svg.append("g")
//    .attr("class", "legendSymbol")
//    .attr("transform", "translate(20, 200)");

// var legendPath = d3.legendSymbol()
//                     .scale(display_type)
//                     .orient("vertical")
//                     .title("Node Types");
//                     // .on("cellclick", function(d){alert("clicked " + d);});

// svg.select(".legendSymbol")
//    .call(legendPath);


/////////////////////////////////////////////////////////////////////////////
                      ///////    Features    ///////
/////////////////////////////////////////////////////////////////////////////

$("#magic").on('input', function () {
    var val = this.value;
    if ($('#nodes').find('option').filter(function() {
        return this.value.toUpperCase() === val.toUpperCase();
    }).length) {
        set_focus(d3.select("#"+this.value)._groups[0][0].__data__);
        set_highlight(d3.select("#"+this.value)._groups[0][0].__data__);
    }
    else { remove_focus(); remove_highlight(); }
});

$("#solutionEdges").change(function() {
    if(this.checked) {
        g.selectAll(".link").filter(function(d) {return !d.in_solution}).style('opacity', 0)
    } else {
        g.selectAll(".link").style('opacity', 1)
    }
});


/////////////////////////////////////////////////////////////////////////////
                      ///////    Download    ///////
/////////////////////////////////////////////////////////////////////////////

// Set-up the export button
d3.select('#saveButton').on('click', function(){
    var svgString = getSVGString(svg.node());
    svgString2Image( svgString, 2*w, 2*h, 'png', save ); // passes Blob and filesize String to the callback

    function save( dataBlob, filesize ){
        saveAs( dataBlob, 'D3 vis exported to PNG.png' ); // FileSaver.js function
    }
});

// Below are the functions that handle actual exporting:
// getSVGString ( svgNode ) and svgString2Image( svgString, width, height, format, callback )
function getSVGString( svgNode ) {
    svgNode.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
    var cssStyleText = getCSSStyles( svgNode );
    appendCSS( cssStyleText, svgNode );

    var serializer = new XMLSerializer();
    var svgString = serializer.serializeToString(svgNode);
    svgString = svgString.replace(/(\w+)?:?xlink=/g, 'xmlns:xlink='); // Fix root xlink without namespace
    svgString = svgString.replace(/NS\d+:href/g, 'xlink:href'); // Safari NS namespace fix

    return svgString;

    function getCSSStyles( parentElement ) {
        var selectorTextArr = [];

        // Add Parent element Id and Classes to the list
        selectorTextArr.push( '#'+parentElement.id );
        for (var c = 0; c < parentElement.classList.length; c++)
                if ( !contains('.'+parentElement.classList[c], selectorTextArr) )
                    selectorTextArr.push( '.'+parentElement.classList[c] );

        // Add Children element Ids and Classes to the list
        var nodes = parentElement.getElementsByTagName("*");
        for (var i = 0; i < nodes.length; i++) {
            var id = nodes[i].id;
            if ( !contains('#'+id, selectorTextArr) )
                selectorTextArr.push( '#'+id );

            var classes = nodes[i].classList;
            for (var c = 0; c < classes.length; c++)
                if ( !contains('.'+classes[c], selectorTextArr) )
                    selectorTextArr.push( '.'+classes[c] );
        }

        // Extract CSS Rules
        var extractedCSSText = "";
        for (var i = 0; i < document.styleSheets.length; i++) {
            var s = document.styleSheets[i];

            try {
                if(!s.cssRules) continue;
            } catch( e ) {
                    if(e.name !== 'SecurityError') throw e; // for Firefox
                    continue;
                }

            var cssRules = s.cssRules;
            for (var r = 0; r < cssRules.length; r++) {
                if ( contains( cssRules[r].selectorText, selectorTextArr ) )
                    extractedCSSText += cssRules[r].cssText;
            }
        }

        return extractedCSSText;

        function contains(str,arr) {
            return arr.indexOf( str ) === -1 ? false : true;
        }
    }

    function appendCSS( cssText, element ) {
        var styleElement = document.createElement("style");
        styleElement.setAttribute("type","text/css");
        styleElement.innerHTML = cssText;
        var refNode = element.hasChildNodes() ? element.children[0] : null;
        element.insertBefore( styleElement, refNode );
    }
}

function svgString2Image( svgString, width, height, format, callback ) {
    var format = format ? format : 'png';

    var imgsrc = 'data:image/svg+xml;base64,'+ btoa( unescape( encodeURIComponent( svgString ) ) ); // Convert SVG string to data URL

    var canvas = document.createElement("canvas");
    var context = canvas.getContext("2d");

    canvas.width = width;
    canvas.height = height;

    var image = new Image();
    image.onload = function() {
        context.clearRect ( 0, 0, width, height );
        context.drawImage(image, 0, 0, width, height);

        canvas.toBlob( function(blob) {
            var filesize = Math.round( blob.length/1024 ) + ' KB';
            if ( callback ) callback( blob, filesize );
        });
    };

    image.src = imgsrc;
}

</script>

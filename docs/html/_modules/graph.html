

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>graph &mdash; OmicsIntegrator2 2.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="OmicsIntegrator2 2.0 documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> OmicsIntegrator2
          

          
          </a>

          
            
            
              <div class="version">
                2.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">OmicsIntegrator2</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>graph</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for graph</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="c1"># Core python modules</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c1"># Peripheral python modules</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="k">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">copy</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">pkg_resources</span> <span class="k">import</span> <span class="n">resource_filename</span> <span class="k">as</span> <span class="n">get_path</span>

<span class="c1"># python external libraries</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">networkx.readwrite</span> <span class="k">import</span> <span class="n">json_graph</span> <span class="k">as</span> <span class="n">nx_json</span>
<span class="kn">import</span> <span class="nn">community</span>    <span class="c1"># pip install python-louvain</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="k">import</span> <span class="n">SpectralClustering</span>
<span class="kn">import</span> <span class="nn">jinja2</span>

<span class="c1"># Lab modules</span>
<span class="kn">from</span> <span class="nn">pcst_fast</span> <span class="k">import</span> <span class="n">pcst_fast</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
<span class="n">handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>
<span class="n">handler</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
<span class="n">handler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%(asctime)s</span><span class="s1"> - OI2: </span><span class="si">%(levelname)s</span><span class="s1"> - </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s2">&quot;%I:%M:%S&quot;</span><span class="p">))</span>
<span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>

<span class="c1"># Count the number of available CPUs for potential use in multiprocessing code</span>
<span class="k">try</span><span class="p">:</span> <span class="n">n_cpus</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;SLURM_JOB_CPUS_PER_NODE&quot;</span><span class="p">])</span>
<span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="n">n_cpus</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>

<span class="c1"># Helpers</span>

<span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">list_of_lists</span><span class="p">):</span> <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">list_of_lists</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">invert</span><span class="p">(</span><span class="n">list_of_lists</span><span class="p">):</span> <span class="k">return</span> <span class="p">{</span><span class="n">item</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="nb">list</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_of_lists</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">safe_string</span><span class="p">(</span><span class="n">unsafe_string</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">unsafe_string</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">isalnum</span><span class="p">())</span>

<span class="k">class</span> <span class="nc">Options</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>


<div class="viewcode-block" id="Graph"><a class="viewcode-back" href="../index.html#graph.Graph">[docs]</a><span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Graph object is a representation of a graph, with convenience methods for using the pcst_fast</span>
<span class="sd">    package, which approximately minimizes the Prize-Collecting Steiner Forest objective.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">###########################################################################</span>
                <span class="c1">#######          Initialization            #######</span>
    <span class="c1">###########################################################################</span>

<div class="viewcode-block" id="Graph.__init__"><a class="viewcode-back" href="../index.html#graph.Graph.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interactome_file</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds a representation of a graph from an interactome file.</span>

<span class="sd">        From the interactome_file, populates</span>
<span class="sd">        - `graph.interactome_dataframe` (pandas.DataFrame)</span>
<span class="sd">        - `graph.interactome_graph` (networkx.Graph)</span>
<span class="sd">        - `graph.nodes` (pandas.Index),</span>
<span class="sd">        - `graph.edges` (list of pairs),</span>
<span class="sd">        - `graph.costs` and `graph.edge_penalties` (lists, such that the ordering is the same as in graph.edges),</span>
<span class="sd">        - `graph.node_degrees` (list, such that the ordering is the same as in graph.nodes).</span>

<span class="sd">        Arguments:</span>
<span class="sd">            interactome_file (str or FILE): tab-delimited text file containing edges in interactome and their weights formatted like &quot;ProteinA\tProteinB\tCost&quot;</span>
<span class="sd">            params (dict): params with which to run the program</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">interactome_dataframe</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">interactome_file</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interactome_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_pandas_edgelist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interactome_dataframe</span><span class="p">,</span> <span class="s1">&#39;protein1&#39;</span><span class="p">,</span> <span class="s1">&#39;protein2&#39;</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interactome_dataframe</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

        <span class="c1"># Convert the interactome dataframe from string interactor IDs to integer interactor IDs.</span>
        <span class="c1"># Do so by selecting the protein1 and protein2 columns from the interactome dataframe,</span>
        <span class="c1"># then unstacking them, which (unintuitively) stacks them into one column, allowing us to use factorize.</span>
        <span class="c1"># Factorize builds two datastructures, a unique pd.Index which maps each ID string to an integer ID,</span>
        <span class="c1"># and the datastructure we passed in with string IDs replaced with those integer IDs.</span>
        <span class="c1"># We place those in self.nodes and self.edges respectively, but self.edges will need reshaping.</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interactome_dataframe</span><span class="p">[[</span><span class="s2">&quot;protein1&quot;</span><span class="p">,</span><span class="s2">&quot;protein2&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">unstack</span><span class="p">())</span>
        <span class="c1"># Here we do the inverse operation of &quot;unstack&quot; above, which gives us an interpretable edges datastructure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interactome_dataframe</span><span class="p">[[</span><span class="s2">&quot;protein1&quot;</span><span class="p">,</span><span class="s2">&quot;protein2&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">edge_costs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interactome_dataframe</span><span class="p">[</span><span class="s1">&#39;cost&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># Count the number of incident edges into each node.</span>
        <span class="c1"># The indices into this datastructure are the same as those in self.nodes which are the IDs in self.edges.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_degrees</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

        <span class="c1"># The rest of the setup work is occasionally repeated, so use another method to complete setup.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_hyperparameters</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_reset_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the parameters on Graph and compute parameter-dependent features.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            params (dict): params with which to run the program</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;w&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;edge_noise&quot;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span> <span class="s2">&quot;dummy_mode&quot;</span><span class="p">:</span> <span class="s2">&quot;terminals&quot;</span><span class="p">,</span> <span class="s2">&quot;seed&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;skip_checks&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>

        <span class="c1"># Overwrite the defaults with any user-specified parameters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">Options</span><span class="p">({</span><span class="o">**</span><span class="n">defaults</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">})</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">skip_checks</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_validity_of_hyperparameters</span><span class="p">()</span>

        <span class="c1"># Add costs to each edge, proportional to the degrees of the nodes it connects, modulated by parameter g.</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_penalties</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">g</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">node_degrees</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_degrees</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">/</span>
                            <span class="p">((</span><span class="n">N</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_degrees</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_degrees</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_degrees</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_degrees</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">costs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_costs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_penalties</span><span class="p">)</span>

        <span class="c1"># If this instance of graph has bare_prizes set, then presumably resetting the</span>
        <span class="c1"># hyperparameters should also reset the scaled prizes</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;bare_prizes&quot;</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">prizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bare_prizes</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">b</span>


    <span class="k">def</span> <span class="nf">_check_validity_of_hyperparameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assert that the hyperparameters passed to this program are valid, otherwise raise helpful error messages.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">w</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;parameter w must be a positive number. Was &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">w</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;parameter b must be a positive number. Was &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">b</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">g</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;parameter g must be a positive number. Was &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">g</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">edge_noise</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">edge_noise</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;parameter edge_noise must be a positive number. Was &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">edge_noise</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">dummy_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;terminals&#39;</span><span class="p">,</span> <span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">]):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;parameter dummy_mode must be one of &#39;terminals&#39;, &#39;other&#39;, or &#39;all&#39;. Was &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">dummy_mode</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">seed</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;parameter seed must be a int. Was type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">seed</span><span class="p">)))</span>


<div class="viewcode-block" id="Graph.prepare_prizes"><a class="viewcode-back" href="../index.html#graph.Graph.prepare_prizes">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_prizes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prize_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses a prize file and adds prizes and other attributes to the graph object.</span>

<span class="sd">        The file passed to this function must have at least two columns: node name and prize.</span>
<span class="sd">        Any additional columns will be assumed to be node attributes. However, in order to know</span>
<span class="sd">        the names of those attributes, this function requires the input file to contain headers,</span>
<span class="sd">        i.e. the first row of the tsv must be the names of the columns.</span>

<span class="sd">        Sets the graph attributes</span>
<span class="sd">        - `graph.bare_prizes` (numpy.array): properly indexed (same as `graph.nodes`) prizes from the file.</span>
<span class="sd">        - `graph.prizes` (numpy.array): properly indexed prizes, scaled by beta (`graph.params.b`)</span>
<span class="sd">        - `graph.terminals` (numpy.array): their indices</span>
<span class="sd">        - `graph.node_attributes` (pandas.DataFrame) Any node attributes passed in with the prize file (columns 3, ...)</span>

<span class="sd">        Arguments:</span>
<span class="sd">            prize_file (str or FILE): a filepath or file object containing a tsv **with column headers**.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">prizes_dataframe</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">prize_file</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">prizes_dataframe</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;prize&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">prizes_dataframe</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">prizes_dataframe</span><span class="p">[</span><span class="s1">&#39;prize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">prizes_dataframe</span><span class="p">[</span><span class="s1">&#39;prize&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_prizes</span><span class="p">(</span><span class="n">prizes_dataframe</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_prepare_prizes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prizes_dataframe</span><span class="p">):</span>

        <span class="c1"># Some files have duplicated genes with different prizes. Keep the max prize.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Duplicated gene symbols in the prize file (we&#39;ll keep the max prize):&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">prizes_dataframe</span><span class="p">[</span><span class="n">prizes_dataframe</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">prizes_dataframe</span> <span class="o">=</span> <span class="n">prizes_dataframe</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="c1"># Find the indices of the nodes being assigned prizes</span>
        <span class="n">prizes_dataframe</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">prizes_dataframe</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># there will be some nodes in the prize file which we don&#39;t have in our interactome</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Members of the prize file not present in the interactome:&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">prizes_dataframe</span><span class="p">[</span><span class="n">prizes_dataframe</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">prizes_dataframe</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>

        <span class="c1"># All nodes in the prizes dataframe are defined to be terminals.</span>
        <span class="n">prizes_dataframe</span><span class="p">[</span><span class="s2">&quot;terminal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">prizes_dataframe</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prizes_dataframe</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;protein&quot;</span><span class="p">)</span>

        <span class="c1"># Node attributes dataframe for all proteins in self.nodes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_attributes</span> <span class="o">=</span> <span class="n">prizes_dataframe</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_attributes</span><span class="p">[</span><span class="s2">&quot;degree&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_degrees</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_attributes</span><span class="p">[</span><span class="s2">&quot;prize&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_attributes</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s2">&quot;protein&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_attributes</span><span class="p">[</span><span class="s2">&quot;terminal&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bare_prizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_attributes</span><span class="p">[</span><span class="s2">&quot;prize&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bare_prizes</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">b</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_attributes</span><span class="p">[</span><span class="s2">&quot;terminal&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


    <span class="c1">###########################################################################</span>
                <span class="c1">#######              PCSF               #######</span>
    <span class="c1">###########################################################################</span>

    <span class="k">def</span> <span class="nf">_add_dummy_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connected_to</span><span class="o">=</span><span class="p">[]):</span>

        <span class="n">dummy_id</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">dummy_prize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">dummy_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">dummy_id</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span> <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="n">connected_to</span><span class="p">])</span>
        <span class="n">dummy_costs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">w</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">dummy_edges</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">dummy_edges</span><span class="p">,</span> <span class="n">dummy_costs</span><span class="p">,</span> <span class="n">dummy_id</span><span class="p">,</span> <span class="n">dummy_prize</span>


    <span class="k">def</span> <span class="nf">_check_validity_of_instance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">prizes</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">num_clusters</span><span class="p">,</span> <span class="n">pruning</span><span class="p">,</span> <span class="n">verbosity_level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assert that the data passed to this program are valid, otherwise raise helpful error messages.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;edges must be a numpy array, type was: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">edges</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;edges must be an array of dimension 2, dimension was: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;edges array must have two columns, number of columns was: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">prizes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;prizes must be a numpy array, type was: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">prizes</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prizes</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;prizes must be an array of dimension 1, dimension was: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prizes</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prizes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">flatten</span><span class="p">()))):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;there must be as many prizes as nodes. # prizes: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prizes</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;, # nodes: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">flatten</span><span class="p">()))))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">costs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;costs must be a numpy array, type was: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">costs</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">costs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;costs must be an array of dimension 1, dimension was: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">costs</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">costs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;there must be as many costs as edges. # costs: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">costs</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;, # edges: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;root must be an int, type was: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">root</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">root</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">prizes</span><span class="p">)):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;root must be one of the nodes in the graph. root: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">root</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;, nodes: [0, &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prizes</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;]&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">num_clusters</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_clusters must be an int, type was: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">num_clusters</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">num_clusters</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">prizes</span><span class="p">)):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_clusters must be greater than 0, and less than the number of nodes. num_clusters was: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">num_clusters</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;# nodes was: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prizes</span><span class="p">)))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">pruning</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="s1">&#39;gw&#39;</span><span class="p">,</span> <span class="s1">&#39;strong&#39;</span><span class="p">]):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pruning must be one of [&#39;none&#39;, &#39;simple&#39;, &#39;gw&#39;, &#39;strong&#39;]. pruning was: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pruning</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">verbosity_level</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;verbosity_level must be an integer, any of [0, 1, 2, 3]. verbosity_level was: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">verbosity_level</span><span class="p">))</span>

        <span class="k">return</span> <span class="kc">True</span>


<div class="viewcode-block" id="Graph.pcsf"><a class="viewcode-back" href="../index.html#graph.Graph.pcsf">[docs]</a>    <span class="k">def</span> <span class="nf">pcsf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pruning</span><span class="o">=</span><span class="s2">&quot;strong&quot;</span><span class="p">,</span> <span class="n">verbosity_level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select the subgraph which approximately optimizes the Prize-Collecting Steiner Forest objective.</span>

<span class="sd">        This function mostly defers to pcst_fast, but does one important pre-processing step: it</span>
<span class="sd">        adds a dummy node which will serve as the PCSF root and connects that dummy node to either</span>
<span class="sd">        terminals, non-terminals, or all other nodes with edges weighted by self.params.w.</span>

<span class="sd">        In order to interpret the results of this function, use `output_forest_as_networkx` with</span>
<span class="sd">        the results of this function.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            pruning (str): a string value indicating the pruning method. Possible values are `&#39;none&#39;`, `&#39;simple&#39;`, `&#39;gw&#39;`, and `&#39;strong&#39;` (all literals are case-insensitive).</span>
<span class="sd">            verbosity_level (int): an integer indicating how much debug output the function should produce.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: indices of the selected vertices</span>
<span class="sd">            numpy.array: indices of the selected edges</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">all</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)))</span>
        <span class="n">others</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">all</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terminals</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">dummy_mode</span> <span class="o">==</span> <span class="s1">&#39;terminals&#39;</span><span class="p">:</span> <span class="n">endpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">dummy_mode</span> <span class="o">==</span> <span class="s1">&#39;other&#39;</span><span class="p">:</span> <span class="n">endpoints</span> <span class="o">=</span> <span class="n">others</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">dummy_mode</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span> <span class="n">endpoints</span> <span class="o">=</span> <span class="nb">all</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Improper input to PCSF: dummy_mode must be one of &#39;terminals&#39;, &#39;other&#39;, or &#39;all&#39;&quot;</span><span class="p">)</span>

        <span class="n">dummy_edges</span><span class="p">,</span> <span class="n">dummy_costs</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">dummy_prize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_dummy_node</span><span class="p">(</span><span class="n">connected_to</span><span class="o">=</span><span class="n">endpoints</span><span class="p">)</span>

        <span class="c1"># `edges`: a 2D int64 array. Each row (of length 2) specifies an undirected edge in the input graph. The nodes are labeled 0 to n-1, where n is the number of nodes.</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="n">dummy_edges</span><span class="p">))</span>
        <span class="c1"># `prizes`: the node prizes as a 1D float64 array.</span>
        <span class="n">prizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">prizes</span><span class="p">,</span> <span class="n">dummy_prize</span><span class="p">))</span>
        <span class="c1"># `costs`: the edge costs as a 1D float64 array.</span>
        <span class="n">costs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">costs</span><span class="p">,</span> <span class="n">dummy_costs</span><span class="p">))</span>
        <span class="c1"># `root`: the root note for rooted PCST. For the unrooted variant, this parameter should be -1.</span>
        <span class="c1"># `num_clusters`: the number of connected components in the output.</span>
        <span class="n">num_clusters</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># `pruning`: a string value indicating the pruning method. Possible values are `&#39;none&#39;`, `&#39;simple&#39;`, `&#39;gw&#39;`, and `&#39;strong&#39;` (all literals are case-insensitive).</span>
        <span class="c1"># `verbosity_level`: an integer indicating how much debug output the function should produce.</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">skip_checks</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_validity_of_instance</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">prizes</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">num_clusters</span><span class="p">,</span> <span class="n">pruning</span><span class="p">,</span> <span class="n">verbosity_level</span><span class="p">)</span>

        <span class="n">vertex_indices</span><span class="p">,</span> <span class="n">edge_indices</span> <span class="o">=</span> <span class="n">pcst_fast</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">prizes</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">num_clusters</span><span class="p">,</span> <span class="n">pruning</span><span class="p">,</span> <span class="n">verbosity_level</span><span class="p">)</span>
        <span class="c1"># `vertex_indices`: indices of the vertices in the solution as a 1D int64 array.</span>
        <span class="c1"># `edge_indices`: indices of the edges in the output as a 1D int64 array. The list contains indices into the list of edges passed into the function.</span>

        <span class="c1"># Remove the dummy node and dummy edges for convenience</span>
        <span class="n">vertex_indices</span> <span class="o">=</span> <span class="n">vertex_indices</span><span class="p">[</span><span class="n">vertex_indices</span> <span class="o">!=</span> <span class="n">root</span><span class="p">]</span>
        <span class="n">edge_indices</span> <span class="o">=</span> <span class="n">edge_indices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">edge_indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interactome_dataframe</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">vertex_indices</span><span class="p">,</span> <span class="n">edge_indices</span></div>


<div class="viewcode-block" id="Graph.output_forest_as_networkx"><a class="viewcode-back" href="../index.html#graph.Graph.output_forest_as_networkx">[docs]</a>    <span class="k">def</span> <span class="nf">output_forest_as_networkx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex_indices</span><span class="p">,</span> <span class="n">edge_indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a networkx graph from a set of vertex and edge indices (i.e. a pcsf output)</span>

<span class="sd">        Arguments:</span>
<span class="sd">            vertex_indices (list): indices of the vertices selected in self.nodes. Note, this list must be of type int or boolean. Errors may arise from empty numpy arrays of dtype=&#39;object&#39;</span>
<span class="sd">            edge_indices (list): indices of the edges selected in self.edges</span>

<span class="sd">        Returns:</span>
<span class="sd">            networkx.Graph: a networkx graph object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;The resulting Forest is empty. Try different parameters.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">empty_graph</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">nx</span><span class="o">.</span><span class="n">empty_graph</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Replace the edge indices with the actual edges (protein1 name, protein2 name) by indexing into the interactome</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interactome_dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">edge_indices</span><span class="p">]</span>
        <span class="n">forest</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_pandas_edgelist</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="s1">&#39;protein1&#39;</span><span class="p">,</span> <span class="s1">&#39;protein2&#39;</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># the above won&#39;t capture the singletons, so we&#39;ll add them here</span>
        <span class="n">forest</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">vertex_indices</span><span class="p">])</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">forest</span><span class="o">.</span><span class="n">nodes</span><span class="p">())))</span>

        <span class="c1"># Set all the attributes on graph</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">forest</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_attributes</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">forest</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">))</span>
        <span class="c1"># Set a flag on all the edges which were selected by PCSF (before augmenting the forest)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">forest</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;in_solution&#39;</span><span class="p">)</span>
        <span class="c1"># Create a new graph including all edges between all selected nodes, not just those edges selected by PCSF.</span>
        <span class="n">augmented_forest</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interactome_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">forest</span><span class="o">.</span><span class="n">nodes</span><span class="p">()),</span> <span class="n">forest</span><span class="p">)</span>

        <span class="c1"># Post-processing</span>
        <span class="n">betweenness</span><span class="p">(</span><span class="n">augmented_forest</span><span class="p">)</span>
        <span class="n">louvain_clustering</span><span class="p">(</span><span class="n">augmented_forest</span><span class="p">)</span>
        <span class="n">annotate_graph_nodes</span><span class="p">(</span><span class="n">augmented_forest</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">forest</span><span class="p">,</span> <span class="n">augmented_forest</span></div>


<div class="viewcode-block" id="Graph.pcsf_objective_value"><a class="viewcode-back" href="../index.html#graph.Graph.pcsf_objective_value">[docs]</a>    <span class="k">def</span> <span class="nf">pcsf_objective_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forest</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate PCSF objective function</span>

<span class="sd">        Arguments:</span>
<span class="sd">            forest (networkx.Graph): a forest like the one returned by output_forest_as_networkx -- Not an augmented forest!</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: PCSF objective function score</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">((</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prizes</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">forest</span><span class="p">,</span> <span class="s1">&#39;prize&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">+</span>
                 <span class="nb">sum</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">forest</span><span class="p">,</span> <span class="s1">&#39;cost&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span>
                 <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">w</span> <span class="o">*</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">forest</span><span class="p">)))</span></div>


    <span class="c1">###########################################################################</span>
                <span class="c1">#######          Randomziations         #######</span>
    <span class="c1">###########################################################################</span>

    <span class="k">def</span> <span class="nf">_noisy_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds gaussian edge_noise to all edge costs in the graph, modulated by parameter `edge_noise`</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: edge weights with added gaussian edge_noise</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">costs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">edge_noise</span><span class="p">),</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># None means don&#39;t clip above</span>


    <span class="k">def</span> <span class="nf">_random_terminals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Switches the terminals with random nodes with a similar degree.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: new prizes</span>
<span class="sd">            numpy.array: new terminals</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nodes_sorted_by_degree</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_degrees</span><span class="p">)</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">index</span>
        <span class="n">terminal_degree_rankings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nodes_sorted_by_degree</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">terminal</span><span class="p">)</span> <span class="k">for</span> <span class="n">terminal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span><span class="p">])</span>
        <span class="n">new_terminal_degree_rankings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">terminal_degree_rankings</span><span class="p">,</span> <span class="mi">10</span><span class="p">)),</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">new_terminals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">nodes_sorted_by_degree</span><span class="p">)[</span><span class="n">new_terminal_degree_rankings</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="n">new_prizes</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prizes</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">old_terminal</span><span class="p">,</span> <span class="n">new_terminal</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terminals</span><span class="p">,</span> <span class="n">new_terminals</span><span class="p">):</span>
            <span class="n">new_prizes</span><span class="p">[</span><span class="n">old_terminal</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">new_prizes</span><span class="p">[</span><span class="n">new_terminal</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prizes</span><span class="p">[</span><span class="n">old_terminal</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">new_prizes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">new_terminals</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_noisy_edges_reps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform PCSF and collect results for some number of noisy edges randomizations</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">true_edge_costs</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">costs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">noisy_edge_costs</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_noisy_edges</span><span class="p">()</span> <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">)]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">costs</span> <span class="o">=</span> <span class="n">noisy_edge_costs</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcsf</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">costs</span> <span class="o">=</span> <span class="n">true_edge_costs</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_pcsf</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="s1">&#39;robustness&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_random_terminal_reps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform PCSF and collect results for some number of random_terminal randomizations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">true_prizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prizes</span>
        <span class="n">true_terminals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span>

        <span class="k">for</span> <span class="n">random_prizes</span><span class="p">,</span> <span class="n">terminals</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_terminals</span><span class="p">()</span> <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">)]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prizes</span> <span class="o">=</span> <span class="n">random_prizes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span> <span class="o">=</span> <span class="n">terminals</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcsf</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prizes</span> <span class="o">=</span> <span class="n">true_prizes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span> <span class="o">=</span> <span class="n">true_terminals</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_pcsf</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="s1">&#39;specificity&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_aggregate_pcsf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">frequency_attribute_name</span><span class="o">=</span><span class="s2">&quot;frequency&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge multiple PCSF results into one DataFrame</span>

<span class="sd">        Arguments:</span>
<span class="sd">            results (list): a list of [(vertex_indices, edge_indices),...] from multiple PCSF runs.</span>
<span class="sd">            frequency_attribute_name (str): Name of the attribute relating to the frequency of occurrence of components in the results.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.DataFrame: vertex indices and their fractional rate of occurrence in the PCSF results</span>
<span class="sd">            pandas.DataFrame: edge indices and their fractional rate of occurrence in the PCSF results</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(),</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># Transposes a list from [(vertex_indices, edge_indices),...] to ([vertex_indices,...], [edge_indices,...])</span>
        <span class="n">vertex_indices</span><span class="p">,</span> <span class="n">edge_indices</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">results</span><span class="p">)</span>

        <span class="c1"># These next steps are just data transformation/aggregation.</span>
        <span class="c1"># 1. Flatten the lists of lists of edge indices and vertex indices</span>
        <span class="c1"># 2. Count the occurrences of each edge and vertex index</span>
        <span class="c1"># 3. Transform from Counter object to DataFrame through list</span>
        <span class="n">vertex_indices_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">vertex_indices</span><span class="p">))</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;node_index&#39;</span><span class="p">,</span><span class="n">frequency_attribute_name</span><span class="p">])</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;node_index&#39;</span><span class="p">)</span>
        <span class="n">edge_indices_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">edge_indices</span><span class="p">))</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;edge_index&#39;</span><span class="p">,</span><span class="n">frequency_attribute_name</span><span class="p">])</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;edge_index&#39;</span><span class="p">)</span>
        <span class="c1"># 4. Convert occurrences to fractions</span>
        <span class="n">vertex_indices_df</span><span class="p">[</span><span class="n">frequency_attribute_name</span><span class="p">]</span> <span class="o">/=</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="n">edge_indices_df</span><span class="p">[</span><span class="n">frequency_attribute_name</span><span class="p">]</span> <span class="o">/=</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vertex_indices_df</span><span class="p">,</span> <span class="n">edge_indices_df</span>


<div class="viewcode-block" id="Graph.randomizations"><a class="viewcode-back" href="../index.html#graph.Graph.randomizations">[docs]</a>    <span class="k">def</span> <span class="nf">randomizations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noisy_edges_reps</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">random_terminals_reps</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Macro function which performs randomizations and merges the results</span>

<span class="sd">        Note that thee parameters are additive, not multiplicative:</span>
<span class="sd">        `noisy_edges_reps` = 5 and `random_terminals_reps` = 5 makes 10 PCSF runs, not 25.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            noisy_edges_reps (int): Number of &quot;Noisy Edges&quot; type randomizations to perform</span>
<span class="sd">            random_terminals_reps (int): Number of &quot;Random Terminals&quot; type randomizations to perform</span>

<span class="sd">        Returns:</span>
<span class="sd">            networkx.Graph: forest</span>
<span class="sd">            networkx.Graph: augmented_forest</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">seed</span><span class="p">:</span> <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">seed</span><span class="p">);</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># For single PCSF run</span>
        <span class="k">if</span> <span class="n">noisy_edges_reps</span> <span class="o">==</span> <span class="n">random_terminals_reps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_forest_as_networkx</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pcsf</span><span class="p">())</span>

        <span class="n">robust_vertices</span><span class="p">,</span>   <span class="n">robust_edges</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_noisy_edges_reps</span><span class="p">(</span><span class="n">noisy_edges_reps</span><span class="p">)</span>
        <span class="n">specific_vertices</span><span class="p">,</span> <span class="n">specific_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_terminal_reps</span><span class="p">(</span><span class="n">random_terminals_reps</span><span class="p">)</span>

        <span class="n">vertex_indices</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">robust_vertices</span><span class="p">,</span> <span class="n">specific_vertices</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">edge_indices</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">robust_edges</span><span class="p">,</span> <span class="n">specific_edges</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">forest</span><span class="p">,</span> <span class="n">augmented_forest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_forest_as_networkx</span><span class="p">(</span><span class="n">vertex_indices</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">edge_indices</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="c1"># Skip attribute setting if solution is empty.</span>
        <span class="k">if</span> <span class="n">forest</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">forest</span><span class="p">,</span> <span class="n">augmented_forest</span>

        <span class="c1"># reindex `vertex_indices` by name: basically we &quot;dereference&quot; the vertex indices to vertex names</span>
        <span class="n">vertex_indices</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">vertex_indices</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>

        <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">forest</span><span class="p">,</span>           <span class="n">vertex_indices</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">forest</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">))</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">augmented_forest</span><span class="p">,</span> <span class="n">vertex_indices</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">augmented_forest</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">forest</span><span class="p">,</span> <span class="n">augmented_forest</span></div>


    <span class="c1">###########################################################################</span>
                <span class="c1">#######          Grid Search          #######</span>
    <span class="c1">###########################################################################</span>

    <span class="k">def</span> <span class="nf">_eval_PCSF_runs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method which sets parameters and performs PCSF randomizations.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            params (dict): dictionary with regular OI2 parameters _AND_ noisy_edge_reps and random_terminals_reps</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Parameter values in string format</span>
<span class="sd">            networkx.Graph: forest</span>
<span class="sd">            networkx.Graph: augmented_forest</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_hyperparameters</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="n">paramstring</span> <span class="o">=</span> <span class="s2">&quot;W_</span><span class="si">{:04.2f}</span><span class="s2">_B_</span><span class="si">{:04.2f}</span><span class="s2">_G_</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">g</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;noisy_edge_reps&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;random_terminals_reps&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Single PCSF run for &quot;</span> <span class="o">+</span> <span class="n">paramstring</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Randomizations for &quot;</span> <span class="o">+</span> <span class="n">paramstring</span><span class="p">)</span>

        <span class="n">forest</span><span class="p">,</span> <span class="n">augmented_forest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomizations</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;noisy_edge_reps&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;random_terminals_reps&quot;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">paramstring</span><span class="p">,</span> <span class="n">forest</span><span class="p">,</span> <span class="n">augmented_forest</span>


<div class="viewcode-block" id="Graph.grid_randomization"><a class="viewcode-back" href="../index.html#graph.Graph.grid_randomization">[docs]</a>    <span class="k">def</span> <span class="nf">grid_randomization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prize_file</span><span class="p">,</span> <span class="n">Ws</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">Bs</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Gs</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">noisy_edges_reps</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">random_terminals_reps</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Macro function which performs grid search or randomizations or both.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            prize_file (str): filepath</span>
<span class="sd">            Gs (list): Values of gamma</span>
<span class="sd">            Bs (list): Values of beta</span>
<span class="sd">            Ws (list): Values of omega</span>
<span class="sd">            noisy_edges_reps (int): Number of robustness experiments</span>
<span class="sd">            random_terminals_reps (int): Number of specificity experiments</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Forest and augmented forest networkx graphs, keyed by parameter string</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">n_cpus</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_prizes</span><span class="p">(</span><span class="n">prize_file</span><span class="p">)</span>

        <span class="n">param_sets</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="n">w</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="n">b</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">:</span> <span class="n">g</span><span class="p">,</span> <span class="s1">&#39;noisy_edge_reps&#39;</span><span class="p">:</span> <span class="n">noisy_edges_reps</span><span class="p">,</span> <span class="s1">&#39;random_terminals_reps&#39;</span><span class="p">:</span> <span class="n">random_terminals_reps</span><span class="p">}</span> <span class="k">for</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">Ws</span><span class="p">,</span> <span class="n">Bs</span><span class="p">,</span> <span class="n">Gs</span><span class="p">)]</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_eval_PCSF_runs</span><span class="p">,</span> <span class="n">param_sets</span><span class="p">)</span>
        <span class="c1"># Convert to dictionary format</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="n">paramstring</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;forest&quot;</span><span class="p">:</span> <span class="n">forest</span><span class="p">,</span> <span class="s2">&quot;augmented_forest&quot;</span><span class="p">:</span> <span class="n">augmented_forest</span><span class="p">}</span> <span class="k">for</span> <span class="n">paramstring</span><span class="p">,</span> <span class="n">forest</span><span class="p">,</span> <span class="n">augmented_forest</span> <span class="ow">in</span> <span class="n">results</span> <span class="p">}</span>

        <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="Graph.grid_search"><a class="viewcode-back" href="../index.html#graph.Graph.grid_search">[docs]</a>    <span class="k">def</span> <span class="nf">grid_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prize_file</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">Bs</span><span class="p">,</span> <span class="n">Gs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Macro function which performs grid search.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            prize_file (str): filepath</span>
<span class="sd">            Gs (list): Values of gamma</span>
<span class="sd">            Bs (list): Values of beta</span>
<span class="sd">            Ws (list): Values of omega</span>

<span class="sd">        Returns:</span>
<span class="sd">            networkx.Graph: forest</span>
<span class="sd">            networkx.Graph: augmented_forest</span>
<span class="sd">            pd.DataFrame: parameters and node membership lists</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_randomization</span><span class="p">(</span><span class="n">prize_file</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">Bs</span><span class="p">,</span> <span class="n">Gs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div></div>



<span class="c1">###############################################################################</span>
            <span class="c1">#######          Subgraph Augmentation        #######</span>
<span class="c1">###############################################################################</span>

<div class="viewcode-block" id="betweenness"><a class="viewcode-back" href="../index.html#graph.betweenness">[docs]</a><span class="k">def</span> <span class="nf">betweenness</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute and add as an attribute the betweenness of each node.</span>

<span class="sd">    Betweenness centrality of a node v is the sum of the fraction of all-pairs shortest paths that pass through v.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        nxgraph (networkx.Graph): a networkx graph, usually the augmented_forest.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;betweenness&#39;</span><span class="p">:</span><span class="n">betweenness</span><span class="p">}</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span><span class="n">betweenness</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">betweenness_centrality</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span></div>


<div class="viewcode-block" id="louvain_clustering"><a class="viewcode-back" href="../index.html#graph.louvain_clustering">[docs]</a><span class="k">def</span> <span class="nf">louvain_clustering</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute &quot;Louvain&quot;/&quot;Community&quot; clustering on a networkx graph, and add the cluster labels as attributes on the nodes.</span>


<span class="sd">    Arguments:</span>
<span class="sd">        nxgraph (networkx.Graph): a networkx graph, usually the augmented_forest.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;louvain_clusters&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">)}</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span><span class="n">cluster</span> <span class="ow">in</span> <span class="n">community</span><span class="o">.</span><span class="n">best_partition</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span></div>


<div class="viewcode-block" id="k_clique_clustering"><a class="viewcode-back" href="../index.html#graph.k_clique_clustering">[docs]</a><span class="k">def</span> <span class="nf">k_clique_clustering</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute &quot;k-Clique&quot; clustering on a networkx graph, and add the cluster labels as attributes on the nodes.</span>

<span class="sd">    See the [networkx docs](https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.community.kclique.k_clique_communities.html#networkx.algorithms.community.kclique.k_clique_communities)</span>

<span class="sd">    Arguments:</span>
<span class="sd">        nxgraph (networkx.Graph): a networkx graph, usually the augmented_forest.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;K-Clique Clustering requires that k be an integer larger than 1.&quot;</span><span class="p">);</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Improper input to k_clique_clustering&quot;</span><span class="p">)</span>

    <span class="n">clustering</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">invert</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">algorithms</span><span class="o">.</span><span class="n">community</span><span class="o">.</span><span class="n">kclique</span><span class="o">.</span><span class="n">k_clique_communities</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="n">k</span><span class="p">)),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;k_clique_clusters&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">nxgraph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="n">clustering</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">))</span></div>


<div class="viewcode-block" id="spectral_clustering"><a class="viewcode-back" href="../index.html#graph.spectral_clustering">[docs]</a><span class="k">def</span> <span class="nf">spectral_clustering</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute &quot;spectral&quot; clustering on a networkx graph, and add the cluster labels as attributes on the nodes.</span>


<span class="sd">    Arguments:</span>
<span class="sd">        nxgraph (networkx.Graph): a networkx graph, usually the augmented_forest.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adj_matrix</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_pandas_adjacency</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">)</span>
    <span class="n">clustering</span> <span class="o">=</span>  <span class="n">SpectralClustering</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">affinity</span><span class="o">=</span><span class="s1">&#39;precomputed&#39;</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">assign_labels</span><span class="o">=</span><span class="s1">&#39;discretize&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">adj_matrix</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;spectral_clusters&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">)}</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span><span class="n">cluster</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">adj_matrix</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">clustering</span><span class="p">)})</span></div>


<div class="viewcode-block" id="annotate_graph_nodes"><a class="viewcode-back" href="../index.html#graph.annotate_graph_nodes">[docs]</a><span class="k">def</span> <span class="nf">annotate_graph_nodes</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Arguments:</span>
<span class="sd">        nxgraph (networkx.Graph): a networkx graph, usually the augmented_forest.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">annotation</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="n">get_path</span><span class="p">(</span><span class="s1">&#39;OmicsIntegrator&#39;</span><span class="p">,</span> <span class="s1">&#39;annotation/final_annotation.pickle&#39;</span><span class="p">))</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">annotation</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="n">Path</span><span class="o">.</span><span class="n">cwd</span><span class="p">()</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="s1">&#39;annotation&#39;</span> <span class="o">/</span> <span class="s1">&#39;final_annotation.pickle&#39;</span><span class="p">)</span>

    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="n">annotation</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nxgraph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">))</span></div>


<span class="c1">###############################################################################</span>
            <span class="c1">#######            Results           #######</span>
<span class="c1">###############################################################################</span>

<div class="viewcode-block" id="summarize_grid_search"><a class="viewcode-back" href="../index.html#graph.summarize_grid_search">[docs]</a><span class="k">def</span> <span class="nf">summarize_grid_search</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">top_n</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">Infinity</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summarizes results of `grid_randomization` or `grid_search` into a matrix where each row is a gene</span>
<span class="sd">    and each column is a parameter run. If summarizing &quot;membership&quot;, entries will be 0 or 1</span>
<span class="sd">    indicating whether or not a node appeared in each experiment. If summarizing &quot;robustness&quot;</span>
<span class="sd">    or &quot;specificity&quot;, entries indicate robustness or specificity values for each experiment.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        results (list of tuples): Results of `grid_randomization` or `grid_search` of form `{&#39;paramstring&#39;: { &#39;forest&#39;: object, &#39;augmented forest&#39;: object}}`</span>
<span class="sd">        mode (str): Reported values &quot;membership&quot;, &quot;robustness&quot;, &quot;specificity&quot;</span>
<span class="sd">        top_n (int): Takes the top_n values of the summary dataframe. top_n=-1 sets no threshold</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Columns correspond to each parameter experiment, indexed by nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Exclude any degenerate results</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="n">paramstring</span><span class="p">:</span> <span class="n">graphs</span> <span class="k">for</span> <span class="n">paramstring</span><span class="p">,</span> <span class="n">graphs</span> <span class="ow">in</span> <span class="n">results</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">graphs</span><span class="p">[</span><span class="s2">&quot;augmented_forest&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;membership&quot;</span><span class="p">:</span> <span class="c1"># Summarize single-run parameter search</span>
        <span class="n">series</span> <span class="o">=</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">graphs</span><span class="p">[</span><span class="s2">&quot;augmented_forest&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="n">paramstring</span><span class="p">)</span> <span class="k">for</span> <span class="n">paramstring</span><span class="p">,</span> <span class="n">graphs</span> <span class="ow">in</span> <span class="n">results</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;robustness&quot;</span><span class="p">:</span> <span class="c1"># Summarize randomized robustness</span>
        <span class="n">series</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_networkx_graph_as_dataframe_of_nodes</span><span class="p">(</span><span class="n">graphs</span><span class="p">[</span><span class="s2">&quot;augmented_forest&quot;</span><span class="p">])[</span><span class="s2">&quot;robustness&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">paramstring</span><span class="p">)</span> <span class="k">for</span> <span class="n">paramstring</span><span class="p">,</span> <span class="n">graphs</span> <span class="ow">in</span> <span class="n">results</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;specificity&quot;</span><span class="p">:</span> <span class="c1"># Summarize randomized specificity</span>
        <span class="n">series</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_networkx_graph_as_dataframe_of_nodes</span><span class="p">(</span><span class="n">graphs</span><span class="p">[</span><span class="s2">&quot;augmented_forest&quot;</span><span class="p">])[</span><span class="s2">&quot;specificity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">paramstring</span><span class="p">)</span> <span class="k">for</span> <span class="n">paramstring</span><span class="p">,</span> <span class="n">graphs</span> <span class="ow">in</span> <span class="n">results</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;`mode` must be one of the following: &#39;membership&#39;, &#39;robustness&#39;, or &#39;specificity&#39;.&quot;</span><span class="p">);</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Improper input to summarize_grid_search&quot;</span><span class="p">)</span>

    <span class="n">node_summary_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># df can get quite large with many sparse entries, so let&#39;s filter for the top_n entries</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_summary_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">top_n</span><span class="p">:</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">node_summary_df</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="n">top_n</span><span class="p">]</span>
        <span class="n">node_summary_df</span> <span class="o">=</span> <span class="n">node_summary_df</span><span class="p">[</span><span class="n">node_summary_df</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">cutoff</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">node_summary_df</span></div>


<div class="viewcode-block" id="get_robust_subgraph_from_randomizations"><a class="viewcode-back" href="../index.html#graph.get_robust_subgraph_from_randomizations">[docs]</a><span class="k">def</span> <span class="nf">get_robust_subgraph_from_randomizations</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">min_component_size</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a graph with robustness attributes, take the top `max_size` robust nodes and</span>
<span class="sd">    prune any &quot;small&quot; components.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        nxgraph (networkx.Graph): Network from randomization experiment</span>
<span class="sd">        max_size (int): Max size of robust network</span>

<span class="sd">    Returns:</span>
<span class="sd">        networkx.Graph: Robust network</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO: Potential alternative approach - from entire network, attempt to remove lowest robustness node.</span>
    <span class="c1"># If removal results in a component of size less than min_size, do not remove.</span>

    <span class="k">if</span> <span class="n">nxgraph</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Augmented forest is empty.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nxgraph</span>

    <span class="c1"># Get indices of top nodes sorted by high robustness, then low specificity. Don&#39;t allow nodes with robustness = 0.</span>
    <span class="n">node_attributes_df</span> <span class="o">=</span> <span class="n">get_networkx_graph_as_dataframe_of_nodes</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">)</span>
    <span class="n">node_attributes_df</span> <span class="o">=</span> <span class="n">node_attributes_df</span><span class="p">[</span><span class="n">node_attributes_df</span><span class="p">[</span><span class="s2">&quot;robustness&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">node_attributes_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s2">&quot;robustness&quot;</span><span class="p">,</span> <span class="s2">&quot;specificity&quot;</span><span class="p">],</span> <span class="n">ascending</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">top_hits</span> <span class="o">=</span> <span class="n">node_attributes_df</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="n">max_size</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">node_attributes_df</span><span class="p">))]</span>
    <span class="c1"># Get robust subnetwork and remove small components.</span>
    <span class="n">robust_network</span> <span class="o">=</span> <span class="n">nxgraph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">top_hits</span><span class="p">)</span>
    <span class="n">robust_network</span> <span class="o">=</span> <span class="n">filter_graph_by_component_size</span><span class="p">(</span><span class="n">robust_network</span><span class="p">,</span> <span class="n">min_component_size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">robust_network</span></div>


<div class="viewcode-block" id="filter_graph_by_component_size"><a class="viewcode-back" href="../index.html#graph.filter_graph_by_component_size">[docs]</a><span class="k">def</span> <span class="nf">filter_graph_by_component_size</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes any components that are less than `min_size`.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        nxgraph (networkx.Graph): Network from randomization experiment</span>
<span class="sd">        min_size (int): Min size of components in `nxgraph`. Set to 2 to remove singletons only.</span>

<span class="sd">    Returns:</span>
<span class="sd">        networkx.Graph: Network with components less than specified size removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">filtered_subgraph</span> <span class="o">=</span> <span class="n">nxgraph</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">small_components</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_component_subgraphs</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">min_size</span><span class="p">]</span>
    <span class="n">filtered_subgraph</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">small_components</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">filtered_subgraph</span></div>


<span class="c1">###############################################################################</span>
            <span class="c1">#######              Export             #######</span>
<span class="c1">###############################################################################</span>

<div class="viewcode-block" id="get_networkx_graph_as_dataframe_of_nodes"><a class="viewcode-back" href="../index.html#graph.get_networkx_graph_as_dataframe_of_nodes">[docs]</a><span class="k">def</span> <span class="nf">get_networkx_graph_as_dataframe_of_nodes</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Arguments:</span>
<span class="sd">        nxgraph (networkx.Graph): any instance of networkx.Graph</span>
<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: nodes from the input graph and their attributes as a dataframe</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">nxgraph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>


<div class="viewcode-block" id="get_networkx_graph_as_dataframe_of_edges"><a class="viewcode-back" href="../index.html#graph.get_networkx_graph_as_dataframe_of_edges">[docs]</a><span class="k">def</span> <span class="nf">get_networkx_graph_as_dataframe_of_edges</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Arguments:</span>
<span class="sd">        nxgraph (networkx.Graph): any instance of networkx.Graph</span>
<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: edges from the input graph and their attributes as a dataframe</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_pandas_edgelist</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="s1">&#39;protein1&#39;</span><span class="p">,</span> <span class="s1">&#39;protein2&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="output_networkx_graph_as_pickle"><a class="viewcode-back" href="../index.html#graph.output_networkx_graph_as_pickle">[docs]</a><span class="k">def</span> <span class="nf">output_networkx_graph_as_pickle</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;pcsf_results.pickle&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Arguments:</span>
<span class="sd">        nxgraph (networkx.Graph): any instance of networkx.Graph</span>
<span class="sd">        output_dir (str): the directory in which to output the graph.</span>
<span class="sd">        filename (str): Filenames ending in .gz or .bz2 will be compressed.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Path: the filepath which was outputted to</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>
    <span class="n">path</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">path</span> <span class="o">/</span> <span class="n">filename</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">write_gpickle</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">path</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span></div>


<div class="viewcode-block" id="output_networkx_graph_as_graphml_for_cytoscape"><a class="viewcode-back" href="../index.html#graph.output_networkx_graph_as_graphml_for_cytoscape">[docs]</a><span class="k">def</span> <span class="nf">output_networkx_graph_as_graphml_for_cytoscape</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;pcsf_results.graphml.gz&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Arguments:</span>
<span class="sd">        nxgraph (networkx.Graph): any instance of networkx.Graph</span>
<span class="sd">        output_dir (str): the directory in which to output the graph.</span>
<span class="sd">        filename (str): Filenames ending in .gz or .bz2 will be compressed.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Path: the filepath which was outputted to</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>
    <span class="n">path</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">path</span> <span class="o">/</span> <span class="n">filename</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">write_graphml</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">path</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span></div>


<div class="viewcode-block" id="output_networkx_graph_as_interactive_html"><a class="viewcode-back" href="../index.html#graph.output_networkx_graph_as_interactive_html">[docs]</a><span class="k">def</span> <span class="nf">output_networkx_graph_as_interactive_html</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="n">attribute_metadata</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span> <span class="n">output_dir</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;graph.html&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Arguments:</span>
<span class="sd">        nxgraph (networkx.Graph): any instance of networkx.Graph</span>
<span class="sd">        output_dir (str): the directory in which to output the file</span>
<span class="sd">        filename (str): the filename of the output file</span>
<span class="sd">    Returns:</span>
<span class="sd">        Path: the filepath which was outputted to</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">templateLoader</span> <span class="o">=</span> <span class="n">jinja2</span><span class="o">.</span><span class="n">FileSystemLoader</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)))</span>
    <span class="n">templateEnv</span> <span class="o">=</span> <span class="n">jinja2</span><span class="o">.</span><span class="n">Environment</span><span class="p">(</span><span class="n">loader</span><span class="o">=</span><span class="n">templateLoader</span><span class="p">)</span>

    <span class="n">graph_json</span> <span class="o">=</span> <span class="n">nx_json</span><span class="o">.</span><span class="n">node_link_data</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="s1">&#39;source_name&#39;</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="s1">&#39;target_name&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="n">link</span><span class="o">=</span><span class="s1">&#39;links&#39;</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">indexOf</span><span class="p">(</span><span class="n">node_id</span><span class="p">):</span> <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">node</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">graph_json</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">])</span> <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">node_id</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">graph_json</span><span class="p">[</span><span class="s2">&quot;links&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[{</span><span class="o">**</span><span class="n">link</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s2">&quot;source&quot;</span><span class="p">:</span><span class="n">indexOf</span><span class="p">(</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;source_name&#39;</span><span class="p">]),</span> <span class="s2">&quot;target&quot;</span><span class="p">:</span><span class="n">indexOf</span><span class="p">(</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;target_name&#39;</span><span class="p">])}}</span> <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">graph_json</span><span class="p">[</span><span class="s2">&quot;links&quot;</span><span class="p">]]</span>
    <span class="n">graph_json</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">graph_json</span><span class="p">)</span>

    <span class="c1"># TODO comment</span>
    <span class="n">max_prize</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="s1">&#39;prize&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="n">max_degree</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="s1">&#39;degree&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="n">max_betweenness</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="s1">&#39;betweenness&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="c1"># TODO cast terminal attr as string or int</span>
    <span class="c1"># TODO safe string every attr?</span>

    <span class="c1"># construct default attribute metadata</span>
    <span class="n">default_attribute_metadata</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;prize&#39;</span>             <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;display&#39;</span><span class="p">:</span> <span class="s1">&#39;color_scale&#39;</span><span class="p">,</span> <span class="s1">&#39;domain&#39;</span><span class="p">:</span> <span class="n">f</span><span class="s1">&#39;[0, {1e-10}, </span><span class="si">{max_prize}</span><span class="s1">]&#39;</span><span class="p">,</span> <span class="s1">&#39;range&#39;</span><span class="p">:</span> <span class="s1">&#39;[&quot;lightgrey&quot;, &quot;white&quot;, &quot;red&quot;]&#39;</span><span class="p">},</span>
        <span class="s1">&#39;degree&#39;</span>            <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;display&#39;</span><span class="p">:</span> <span class="s1">&#39;color_scale&#39;</span><span class="p">,</span> <span class="s1">&#39;domain&#39;</span><span class="p">:</span> <span class="n">f</span><span class="s1">&#39;[0, </span><span class="si">{max_degree}</span><span class="s1">]&#39;</span><span class="p">,</span> <span class="s1">&#39;range&#39;</span><span class="p">:</span> <span class="s1">&#39;[&quot;lightblue&quot;, &quot;red&quot;]&#39;</span><span class="p">},</span>
        <span class="s1">&#39;betweenness&#39;</span>       <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;display&#39;</span><span class="p">:</span> <span class="s1">&#39;color_scale&#39;</span><span class="p">,</span> <span class="s1">&#39;domain&#39;</span><span class="p">:</span> <span class="n">f</span><span class="s1">&#39;[0, </span><span class="si">{max_betweenness}</span><span class="s1">]&#39;</span><span class="p">,</span> <span class="s1">&#39;range&#39;</span><span class="p">:</span> <span class="s1">&#39;[&quot;purple&quot;, &quot;orange&quot;]&#39;</span><span class="p">},</span>
        <span class="s1">&#39;terminal&#39;</span>          <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;display&#39;</span><span class="p">:</span> <span class="s1">&#39;color_scale&#39;</span><span class="p">,</span> <span class="s1">&#39;domain&#39;</span><span class="p">:</span>  <span class="s1">&#39;[false, true]&#39;</span><span class="p">,</span> <span class="s1">&#39;range&#39;</span><span class="p">:</span> <span class="s1">&#39;[&quot;grey&quot;, &quot;orange&quot;]&#39;</span><span class="p">},</span>

        <span class="s1">&#39;type&#39;</span>              <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;display&#39;</span><span class="p">:</span> <span class="s1">&#39;shape&#39;</span> <span class="p">},</span>
        <span class="s1">&#39;louvain_clusters&#39;</span>  <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;display&#39;</span><span class="p">:</span> <span class="s1">&#39;box&#39;</span> <span class="p">},</span>
        <span class="s1">&#39;location&#39;</span>          <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;display&#39;</span><span class="p">:</span> <span class="s1">&#39;box&#39;</span> <span class="p">},</span>
        <span class="s1">&#39;general_function&#39;</span>  <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;display&#39;</span><span class="p">:</span> <span class="s1">&#39;color_category&#39;</span> <span class="p">},</span>
        <span class="s1">&#39;specific_function&#39;</span> <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;display&#39;</span><span class="p">:</span> <span class="s1">&#39;color_category&#39;</span> <span class="p">},</span>
        <span class="s1">&#39;general_process&#39;</span>   <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;display&#39;</span><span class="p">:</span> <span class="s1">&#39;box&#39;</span> <span class="p">},</span>
        <span class="s1">&#39;specific_process&#39;</span>  <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;display&#39;</span><span class="p">:</span> <span class="s1">&#39;box&#39;</span> <span class="p">},</span>
    <span class="p">}</span>

    <span class="c1"># TODO comment</span>
    <span class="n">all_graph_attribute_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">flatten</span><span class="p">([</span><span class="n">attrs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">attrs</span> <span class="ow">in</span> <span class="n">nxgraph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)]))</span>
    <span class="n">default_attribute_metadata</span> <span class="o">=</span> <span class="p">{</span><span class="n">attr</span><span class="p">:</span> <span class="n">metadata</span> <span class="k">for</span> <span class="n">attr</span><span class="p">,</span><span class="n">metadata</span> <span class="ow">in</span> <span class="n">default_attribute_metadata</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">all_graph_attribute_keys</span><span class="p">}</span>
    <span class="n">unaccounted_for_attributes</span> <span class="o">=</span> <span class="n">all_graph_attribute_keys</span> <span class="o">-</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">default_attribute_metadata</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">attribute_metadata</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="n">inferred_attribute_metadata</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">unaccounted_for_attributes</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Inferring display parameters for </span><span class="si">{attr}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">nxgraph</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]):</span>
            <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">inferred_attribute_metadata</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;display&#39;</span><span class="p">:</span> <span class="s1">&#39;color_scale&#39;</span><span class="p">,</span> <span class="s1">&#39;domain&#39;</span><span class="p">:</span> <span class="n">f</span><span class="s1">&#39;[{min(values)},0,{max(values)}]&#39;</span><span class="p">,</span> <span class="s1">&#39;range&#39;</span><span class="p">:</span><span class="s1">&#39;[&quot;blue&quot;,&quot;white&quot;,&quot;red&quot;]&#39;</span><span class="p">}</span>
            <span class="k">elif</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="nb">min</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span>
                <span class="n">inferred_attribute_metadata</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;display&#39;</span><span class="p">:</span> <span class="s1">&#39;color_scale&#39;</span><span class="p">,</span> <span class="s1">&#39;domain&#39;</span><span class="p">:</span> <span class="n">f</span><span class="s1">&#39;[0,{max(values)}]&#39;</span><span class="p">,</span> <span class="s1">&#39;range&#39;</span><span class="p">:</span><span class="s1">&#39;[&quot;white&quot;,&quot;red&quot;]&#39;</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inferred_attribute_metadata</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;display&#39;</span><span class="p">:</span> <span class="s1">&#39;color_scale&#39;</span><span class="p">,</span> <span class="s1">&#39;domain&#39;</span><span class="p">:</span> <span class="n">f</span><span class="s1">&#39;[{min(values)},{max(values)}]&#39;</span><span class="p">,</span> <span class="s1">&#39;range&#39;</span><span class="p">:</span><span class="s1">&#39;[&quot;purple&quot;,&quot;orange&quot;]&#39;</span><span class="p">}</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;_clusters&#39;</span> <span class="ow">in</span> <span class="n">attr</span><span class="p">:</span>
                <span class="n">inferred_attribute_metadata</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;display&#39;</span><span class="p">:</span> <span class="s1">&#39;box&#39;</span> <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inferred_attribute_metadata</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;display&#39;</span><span class="p">:</span> <span class="s1">&#39;color_category&#39;</span> <span class="p">}</span>

    <span class="c1"># TODO comment</span>
    <span class="n">attribute_metadata</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">default_attribute_metadata</span><span class="p">,</span> <span class="o">**</span><span class="n">inferred_attribute_metadata</span><span class="p">,</span> <span class="o">**</span><span class="n">attribute_metadata</span><span class="p">}</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Final display parameters:&#39;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">attribute_metadata</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>

    <span class="c1"># TODO cast attribute_metadata to list?</span>

    <span class="c1"># TODO comment</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>
    <span class="n">path</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">path</span> <span class="o">/</span> <span class="n">filename</span>

    <span class="n">html_output</span> <span class="o">=</span> <span class="n">templateEnv</span><span class="o">.</span><span class="n">get_template</span><span class="p">(</span><span class="s1">&#39;viz.jinja&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">render</span><span class="p">(</span>
            <span class="n">graph_json</span><span class="o">=</span><span class="n">graph_json</span><span class="p">,</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">nxgraph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(),</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">attribute_metadata</span><span class="p">)</span>

    <span class="n">path</span><span class="o">.</span><span class="n">write_text</span><span class="p">(</span><span class="n">html_output</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">path</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span></div>

</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Alexander LeNail.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'2.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>